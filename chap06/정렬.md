## 정렬	

### 정렬이란?

정렬(Sorting)은 데이터 집합을 핵심 항목(Key)의 대소관계에 따라 일정한 순서로 줄지어 늘어서도록 바꾸는 작업을 말한다. 이 알고리즘을 이용해 데이터를 정렬하면 검색을 더 쉽게 할 수 있다. 키 값이 작은 데이터를 앞쪽에 놓으면 오름차순(Ascending order) 정렬, 그 반대는 내림차순(Descending order) 정렬이라고 부른다. 

![](./Figure/정렬1.JPG)



#### 정렬 알고리즘의 안정성

정렬 알고리즘은 안정된(Stable) 알고리즘과 그렇지 않은 알고리즘으로 나눌 수 있다. 안정된 정렬이란 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것을 말한다. 안정되지 않은 알고리즘은 같은 값을 가진 요소인 경우 반드시 키값 순서대로 정렬되지는 않는다.

![](./Figure/정렬2.JPG)



#### 내부 정렬과 외부 정렬

- 내부 정렬(Internal sorting) : 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우 사용.
- 외부 정렬(External sorting) : 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없을 때 사용.



#### 정렬 알고리즘의 핵심 요소

정렬 알고리즘의 핵심 요소는 교환, 선택, 삽입이며 대부분의 정렬 알고리즘은 이 세 가지 요소르 응용한다. 



## 버블 정렬

### 버블 정렬

![](./Figure/정렬3.JPG)

오름차순으로 배열을 정렬하고자 할 때, 먼저 끝에 있는 두 요소 9와 8을 비교한다. 왼쪽의 값이 오른쪽의 값보다 작아야 하므로 9와 8의 위치를 바꿔준다. 그 다음으로 1과 8을 비교한다. 1은 8보다 작으므로 교환할 필요가 없다. 이렇게 이웃한 요소를 비교하고 교환하는 작업을 첫 번째 요소까지 계속한다. 요소의 개수가 n개인 배열에서 n-1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동한다. 이런 일련의 과정(비교, 교환 작업)을 패스(Pass)라고 한다.

![](./Figure/정렬4.JPG)

이어서 배열의 2번째 이상의 요소에 대해서 패스를 수행한다. 이 패스를 수행하고 나면 3은 배열의 2번째 자리로 이동하고 두 요소의 정렬이 끝난다. 두 번째 패스의 비교 횟수는 첫 번째 패스보다 1회 적은 n-2회인데 패스를 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문이다. 모든 정렬이 끝나려면 n-1회의 패스가 수행되어야 한다(마지막 요소는 n-1번째 패스때 이미 끝에 놓이기 때문).



#### 버블 정렬 프로그램 

![](./Figure/정렬5.JPG)

변수 i의 값을 0부터 n - 2까지 1씩 증가하며 n - 1회의 패스를 수행하는 프로그램은 위와 같다. 여기서 비교하는 두 인덱스를 j-1, j라 한다. 배열의 끝(오른쪽)부터 스캔하기 때문에 j의 시작 값을 n-1로 한다. 패스 과정을 수행하면서 j의 값을 1씩 감소시켜 맨 뒤부터 점점 앞의 요소를 조사한다. 각 패스에서 앞쪽 i개의 요소는 정렬이 끝난 상태라고 가정하기 때문에 한 번의 패스에서는 j의 값이 i + 1이 될 때까지 비교, 교환을 수행한다. 서로 한 칸 이상 떨어져 있는 요소를 교환하는 것이 아니라 서로 이웃한 요소에 대해서만 교환하므로 이 정렬 알고리즘은 안정적이라고 할 수 있다. 총 비교 횟수는 다음과 같다. 

- (n-1) + (n-2) + ... + 1 = n(n-1)/2

그러나 실제 요소를 교환하는 횟수는 배열의 요솟값에 더 많이 영향을 받기 때문에 교환 횟수의 평균 값은 비교횟수의 절반인 n(n-1)/4 이다. 또 C의 경우 swap을 하는 과정에서 값의 이동이 3회 발생하므로 이동 횟수의 평균은 3n(n-1)/4 회이다. 



#### 알고리즘 개선(1)

![](./Figure/정렬6.JPG)

세 번째 패스를 마치고 나면 4가 3번째 자리에 위치한다.

![](./Figure/정렬7.JPG)

네 번째 패스에서 비교는 하되, 교환하지는 않는다. 그 이유는 세 번째 패스에서 이미 6이 정렬을 마쳤기 때문이다. 마찬가지로 다섯 번째, 여섯 번째 패스에서도 요소 교환을 하지 않는다. 즉, 어떤 패스에서 요소의 교환 횟수가 0이면 더 이상 정렬할 요소가 없다는 뜻이기 때문에 정렬 작업을 멈추면 된다. 이는 각 패스를 시행하기 전에 교환 횟수를 카운트하는 변수를 0으로 초기화 하고 교환이 실행할 때마다 이 변수를 1씩 증가시킨다. 패스가 끝나고 이 변수의 값이 0이면 더이상 정렬할 요소가 없다는 뜻이기 때문에 정렬을 멈추는 것으로 구현할 수 있다. 



#### 알고리즘 개선(2)

![](./Figure/정렬8.JPG)

9와 4를 교환하고 나서 {1, 3, 4} 요소는 정렬된 상태이다. 이렇게 각각의 패스에서 비교, 교환을 하다가 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬을 마찬 상태라고 볼 수 있다. 따라서 이 후의 패스에서는 두 번째 요소 이상에서 비교, 교환이 아니라 정렬된 요소 이후에 대해서 비교, 교환을 수행하면 된다. 

![](./Figure/정렬9.JPG)

각 패스 이전에 마지막으로 교환한 두 요소 가운데 오른쪽 요소의 인덱스를 저장하기 위한 변수를 셋팅해 놓고 교환을 수행할 때마다 오른쪽 요소의 인덱스 값을 이 변수에 저장한다. 하나의 패스를 마치고 나면 이 인덱스 값 이후의 요소에 대해서만 비교, 교환을 진행하면 된다. 



## 단순 선택 정렬

단순 선택 정렬(Straight selection sort)은 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘이다.

### 단순 선택 정렬

![](./Figure/정렬10.JPG)

단순 선택 정렬의 교환 과정은 아래와 같다.

- 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min])을 선택한다.
- a[min]과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환한다.

위 과정을 n - 1회 반복하면 된다. 단순 선택 정렬 알고리즘의 요솟값을 비교하는 횟수는 (n^2 - n) / 2회이다. 그런데 이 정렬 알고리즘은 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 않다. 아래 그림을 보면 값이 3인 요소가 중복해서(2개) 있을 때 두 요소의 순서가 뒤바뀌는 것을 알 수 있다(정렬 전 앞쪽 요소를 L, 뒤쪽 요소를 R이라고 했을 때).

![](./Figure/정렬11.JPG)



## 단순 삽입 정렬

단순 삽입 정렬(Straight insertion sort)은 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 삽입하는 작업을 반복하여 정렬하는 알고리즘이다. 단순 선택 정렬과는 다르게 값이 가장 작은 요소를 선택해 알맞은 위치로 옮긴다. 

### 단순 삽입 정렬

정렬된 부분과 아직 정렬되지 않은 부분에서 배열이 다시 구성된다고 생각하면서 아래의 작업을 n - 1회 반복하면 정렬을 마치게 된다.

- 아직 정렬되지 않은 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입한다.

![](./Figure/정렬12.JPG)

즉 i를 1, 2, ..., n - 1로 1씩 증가시키며 인덱스가 i인 요소를 꺼내 알맞은 곳에 삽입한다. 

![](./Figure/정렬13.JPG)

위 작업을 위해서 tmp에 a[i]를 대입(3을 선택)하고 반복 제어용 변수 j에 i - 1을 대입한 다음 아래의 두 조건 중 하나를 만족할 때까지 j를 1씩 감소하면서 대입하는 작업을 반복한다.

- 정렬된 열의 왼쪽 끝에 도달한다.
- tmp보다 작거나 같은 key를 갖는 항목 a[j]를 발견한다. 

이때 드모르간 법칙을 적용하면(반복문의 조건식을 위해서) 아래의 두 조건이 모두 성립할 때까지 반복한다. 

- j가 0보다 크다.
- a[j - 1]값이 tmp보다 크다.

위 과정을 마치고 난 다음에 요소 a[j]에 tmp를 대입하면 한 요소에 대한 단순 삽입 정렬을 마치게 된다. 이렇게 구현한 단순 삽입 정렬 알고리즘은 떨어져 있는 요소들이 서로 뒤바뀌지 않아 안정적이다. 요소의 비교횟수와 교환 횟수는 n^2/2회이다. 단순 삽입 정렬은 셔틀 정렬(Shuttle sort)이라고도 한다.



#### 단순 정렬의 시간 복잡도

세 가지 단순 정렬(버블, 선택, 삽입)의 시간 복잡도는 모두 O(n^2)이다(효율이 좋지 않다).



## 셸 정렬

### 단순 삽입 정렬의 특징

![](./Figure/정렬14.JPG)

위의 그림을 보면 1~5까지는 정렬되어 있기 때문에 빨리 마칠 수 있지만 0을 삽입하려면 1~5를 옆으로 옮기는 작업이 필요하다. 다음은 단순 삽입 정렬의 특징을 정리한 것이다.

- 장점 : 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라진다.
- 단점 : 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아진다.



### 셸 정렬

셸 정렬(Shell sort)은 단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘으로, 도날드 셸(D. L. Shell)이 고안하여 셸 정렬이라고 한다.  먼저 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고, 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄인다. 

![](./Figure/정렬15.JPG)

먼저 배열을 4개의 그룹으로 ({8, 7}, {1, 6}, ...)으로 나누고 각 그룹별로 정렬한다. 위와 같이 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법을 4-정렬이라고 한다. 정렬을 완전히 마치지는 않았지만 정렬을 마친 상태에 가까워진다. 

![](./Figure/정렬16.JPG)

다음으로 4-정렬을 마친 상태에서 2칸만큼 떨어진 요소를 모아 두 그룹({7, 3, 8, 4}, {1, 2, 5, 6})으로 나누어 2-정렬을 한다. 이렇게 해서 얻은 배열은 좀 더 정렬된 상태에 가까워진다. 마지막으로 1-정렬을 적용하면 정렬을 마치게 된다. 

셸 정렬 과정에서 각각의 정렬을 h-정렬이라고 한다. 위의 경우, h 값을 4, 2, 1로 감소하면서 7회의 정렬로 정렬을 마치게 된다.

1. 2개 요소에 대해 4-정렬을 한다(4개의 그룹).
2. 4개 요소에 대해 2-정렬을 한다(2개의 그룹).
3. 8개 요소에 대해 1-정렬을 한다(1개의 그룹).

![](./Figure/정렬17.JPG)

이렇게 하면 정렬해야 하는 횟수는 늘지만 전체적으로는 요소 이동 횟수가 줄어들어 효율적인 정렬을 할 수 있다. 



#### 증분값(h 값)의 선택

h값은 n부터 감소하여 마지막에 1이 된다. 앞에서 했던 배열을 그룹으로 나누는 과정은 다음과 같다.

![](./Figure/정렬18.JPG)

먼저 b처럼 학생을 2명씩 4개의 그룹으로 나누어 정렬하고 c처럼 학생을 4명씩 2개의 그룹으로 나누어 다시 정렬한다. 여기서 b의 2개의 그룹을 각각 합치면 c의 그룹이 된다. 즉 초록색 그룹과 회색 그룹은 섞이지 않는다. 그런데 이렇게 섞이지 않으면 c를 합쳤을 때 다시 처음 단계인 a와 동일해진다. 이런 문제를 해결하기 위해서는 h 값이 서로 배수가 되지 않도록 해야 한다. 이렇게 하면 요소가 충분히 섞여 효율적인 정렬으 기대할 수 있다. 다음의 수열을 사용하면 셸 정렬 알고리즘을 간단히 만들 수 있을 뿐만 아니라 효율적인 결과도 얻을 수 있다. 

- h = ..., 121, 40, 13, 4, 1 (1부터 시작하여 3배한 값에 1을 더하는 수열)

h의 초기값은 너무 크면 효과가 없기 때문에 배열의 요소 개수 n을 9로 나눈 값을 넘지 않도록 해야 한다. 셸 정렬의 시간 복잡도는 O(n^1.25)이지만 멀리 떨어져 있는 요소를 교환해야 하므로 안정적이지는 않다. 