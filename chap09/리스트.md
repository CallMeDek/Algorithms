## 선형 리스트

### 선형 리스트란?

![](./Figure/리스트1.JPG)

리스트는 위와 같이 데이터를 순서대로 나열해 놓은 자료구조를 말한다. 

![](./Figure/리스트2.JPG)

가장 단순한 구조를 가진 리스트를 선형 리스트(Linear list) 또는 연결 리스트(Linked list)라고 한다. 위의 그림을 보면 A부터 F까지 데이터가 순서대로 나열되어 있고 각각의 데이터가 화살표로 연결되어 있음을 알 수 있다. 이때 리스트의 데이터는 노드(Node) 또는 요소(Element)라고 한다. 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있다. 처음과 끝에 있는 노드는 특별히 각각 머리 노드(Head node), 꼬리 노드(Tail node)라고 한다. 또한 하나의 노드에 대해 바로 앞에 있는 노드를 앞쪽 노드(Predecessor node), 바로 뒤에 있는 노드를 다음 노드(Successor node)라고 한다. 



### 배열로 선형 리스트 만들기

![](./Figure/리스트3.JPG)

위와 같이 전화번호부를 선형 리스트로 저장하기 위해 배열로 구현할 수 있다. 



#### 다음 노드 꺼내기

배열의 각 요소에는 연락할 순서대로 데이터가 저장되어 있다. 전화를 걸기 위해 필요한 다음 노드 꺼내기는 1만큼 큰 인덱스를 갖는 요소에 접근하면 된다. 



#### 노드의 삽입과 삭제

새로운 데이터를 삽입하려면 b와 같이 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야 한다. 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당겨야 한다. 이런 작업이 필요하기 때문에 배열로 구현한 선형 리스트는 다음과 같은 문제를 갖게 된다.

- 쌓이는 데이터의 크기를 미리 알아야 한다.
- 데이터의 삽입, 삭제에 따라 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않다. 



## 포인터로 연결 리스트 만들기

### 포인터로 연결 리스트 만들기

연결 리스트에 데이터를 삽입할 때 노드용 객체를 만들고, 삭제할 때 노드용 객체를 없애면 앞에서 제시한 데이터를 밀고 당기는 문제를 해결할 수 있다. 

![](./Figure/리스트4.JPG)

위의 구조체는 다음의 멤버로 구성되어 있다.

- data : 데이터를 저장하는 멤버
- next : 자기 자신과 같은 구조체를 가리키는 포인터

위와 같이 자기 자신과 같은 자료형의 객체를 가리키는 데이터를 가지고 있는 자료구조를 자기 참조(Self-referential)형이라고 한다. 멤버 next에 넣어두는 값은 해당 노드의 다음 노드를 가리키는 포인터이다. 다음 노드를 갖지 않는 꼬리 노드의 next 값은 널(NULL) 값을 대입한다. 



#### 연결리스트를 관리하는 구조체 List

헤더에 Node와는 별개로 List라는 구조체를 선언한다. List는 연결 리스트를 관리하며 두 멤버(머리 노드에 대한 포인터, 선택한 노드에 대한 포인터)로 구성되어 있고 Node에 대한 포인터 자료형을 가지고 있다.  이는 검색한 노드를 선택하고 삭제하는 용도로 사용한다.



#### 노드를 만드는 AllocNode 함수

AllocNode 함수는 Node형 객체를 만들고 만든 객체의 포인터를 반환한다.



#### 노드의 멤버 값을 설정하는 SetNode 함수

SetNode 함수는 Node형 객체의 두 멤버(data, next)의 값을 설정하는 함수이다. 첫 번째 매개변수 n으로 전달받은 포인터가 가리키는 Node형 객체에 x가 가리키는 값을 대입하고 n의 next에 세 번째 매개변수로 전달받은 next를 대입한다.



#### 연결 리스트를 초기화하는 Initialize 함수

Initialize 함수는 연결 리스트를 사용하기 전에 초기화하는 함수이다.  머리 노드를 가리키는 list->head에 널(NULL)값을 대입하여 노드가 하나도 없는 텅 빈 연결 리스트를 만든다. 빈 연결 리스트는 노드가 하나도 없는 상태이기 때문에 head가 가리키는 노드도 없다. 

![](./Figure/리스트5.JPG)



#### 연결 리스트가 비어 있는지 판단하는 방법

위 그림에서 a는 노드가 하나도 없는 상태이다. 이때 리스트가 비어 있는지 판단하는 방법은 다음과 같다.

- list->heat == NULL



#### 노드가 1개인 연결 리스트를 판단하는 방법

b는 연결 리스트에 노드가 1개만 있는 상태이다. 변수 list->head가 가리키는 노드는 머리 노드 A이다. 이떄 연결 리스트에는 1개의 노드만 있기 때문에 머리 노드 A는 리스트의 꼬리 노드이기도 하다. 따라서 next의 값은 널이다. list->head가 가리키는 노드 안의 뒤쪽 포인터 next 값이 널이므로 연결 리스트의 노드가 1개인지 판단하는 방법은 다음과 같다.

- list->next->head == NULL



#### 노드가 2개인 연결 리스트를 판단하는 방법

c는 노드가 2개 있는 상태이다. 머리 노드는 A, 꼬리 노드는 B이다. 이때 list->head가 가리키는 노드 A의 next는 노드 B를 가리킨다. 꼬리 노드 B의 next는 널 값을 가지고 있기 때문에 연결 리스트의 노드가 2개인지 판단하는 방법은 다음과 같다.

- list->head->next->next == NULL



#### 머리 노드인지 판단하는 방법

자료형이 Node *형인 변수 p는 리스트의 노드 중 하나를 가리킨다. 변수 p가 가리키는 노드가 연결 리스트의 머리 노드인지 판단하는 방법은 다음과 같다.

- p == list->head



#### 꼬리 노드인지 판단하는 방법

자료형이 Node *형인 변수 p는 리스트의 노드 중 하나를 가리킨다. 변수 p가 가리키는 노드가 연결 리스트의 꼬리 노드인지 판단하는 방법은 다음과 같다.

- p->next == NULL



#### 검색을 수행하는 Search 함수

Search 함수는 어떤 조건을 만족하는 노드를 검색한다. 반환하는 값은 찾은 노드에 대한 포인터이다. 만약 검색에 실패하면 널을 반환한다. 검색에 사용하는 알고리즘은 선형 검색이고 검색할 노드를 만날때까지 머리 노드부터 스캔한다. 

![](./Figure/리스트6.JPG)

노드 스캔은 다음 조건 중 하나만 성립하면 종료된다.

- 검색 조건을 만족하는 노드를 찾지 못하고 꼬리 노드를 지나가기 직전인 경우
- 검색 조건을 만족하는 노드를 찾은 경우

이 함수가 전달받는 매개변수는 다음과 같다.

- list - 검색 대상인 연결 리스트를 가리키는 포인터
- x - 검색하는 키 값을 저장한 데이터를 가리키는 포인터
- compare - 두 번째 매개변수 x가 가리키는 객체와 연결 리스트의 노드와 데이터를 비교하는 함수를 가리키는 포인터. 검색에 성공하면 0을 반환한다. 

| ![](./Figure/리스트7.JPG) |
| ------------------------------------- |
| ![](./Figure/리스트8.JPG) |
| ![](./Figure/리스트9.JPG) |



#### 머리에 노드를 삽입하는 InsertFront 함수

InsertFront 함수는 연결 리스트의 머리에 노드를 삽입하는 함수이다. 

![](./Figure/리스트10.JPG)

1. 삽입 전의 머리 노드 A에 대한 포인터를 ptr에 대입한다.
2. 삽입할 노드 G를 AllocNode 함수로 만들고 만든 노드 G를 가리키도록 list->head를 업데이트 한다. 
3. SetNode 함수를 호출하여 값을 설정한다. 이때 삽입한 다음 머리 노드의 다음을 가리키는 포인터의 값을 ptr(삽입하기 전의 전의 머리 노드)로 업데이트 한다. 



#### 꼬리에 노드를 삽입하는 InsertRear 함수

InsertRear 함수는 연결 리스트 꼬리에 노드를 삽입하는 함수이다. 리스트가 비어 있는지 아닌지 먼저 확인(list->head == NULL)하고 경우에 따라 다음의 작업을 수행한다.

- 리스트가 비어 있는 경우 : 머리에 노드를 삽입하는 처리와 같다. InsertFront 함수로 처리한다.
- 리스트가 비어 있지 않은 경우 : 리스트 꼬리에 노드 G를 삽입한다. 

![](./Figure/리스트11.JPG)



#### 머리 노드를 삭제하는 RemoveFront 함수

RemoveFront 함수는 머리 노드를 삭제하는 함수이다. 리스트가 비어 있지 않은 경우(list->head != NULL)에만 삭제를 실행한다. 

![](./Figure/리스트12.JPG)

a의 리스트에서 머리 노드 A를 삭제하고 나면 b상태가 된다. 머리 노드에 대한 포인터 list->head에 두 번째 노드 B에 대한 포인터 list->head->next를 대입하여 list->head가 가리키는 노드를 B로 업데이트 한다. 그리고 삭제하기 전의 머리 노드 A의 메모리 영역을 해제한다. 만약 리스트에 노드가 1개만 있어도 오류 없이 삭제할 수 있다. 삭제하기 전의 머리 노드는 꼬리 노드이기 때문에 다음 노드를 가리키는 list->head->next의 값은 널이다. 널을 list->head에 대입하면 리스트는 빈 상태가 된다. 



#### 꼬리 노드를 삭제하는 RemoveRear 함수

RemoveRear 함수는 꼬리 노드를 삭제하는 함수이다. 리스트에 노드가 몇 개 있는지에 따라 그 경우에 해당하는 작업을 수행한다.

- 리스트에 노드가 1개만 있는 경우 : 머리 노드를 삭제하는 것과 같으므로 RemoveFront 함수로 처리한다.
- 리스트에 노드가 2개 이상 있는 경우 : 아래 참조



1. 먼저 꼬리 노드와 꼬리 노드로부터 두 번째 노드를 찾는다. 스캔하는 방법은 InsertRear함수와 비슷하지만 현재 스캔하고 있는 노드의 앞에 있는 노드를 가리키는 변수를 추가한점이 다르다.
2. 꼬리 노드로부터 두 번째 노드 E의 다음을 가리키는 포인터에 널을 대입하고 꼬리 노드의 메모리 영역을 해제한다. 

![](./Figure/리스트13.JPG)



#### 선택한 노드를 삭제하는 RemoveCurrent 함수

RemoveCurrent 함수는 현재 선택한 노드(list->crnt)가 가리키는 노드를 삭제하는 함수이다. 선택한 노드가 머리 노드인지 아닌지에 따라 다음의 작업을 수행한다.

- crnt가 머리 노드인 경우 : 머리 노드를 삭제하면 된다. RemoveFront 함수로 처리한다.
- crnt가 머리 노드가 아닌 경우 : 아래 참조.

![](./Figure/리스트14.JPG)

1. 선택한 노드의 앞 노드를 찾는다. while 문은 머리 노드부터 스캔을 시작한다. 선택한 노드 ptr의 다음 노드를 가리키는 포인터 ptr->next가 list->crnt와 같을때까지 반복한다. while문이 종료되고 난 다음 ptr이 가리키는 노드는 삭제하기 위해 선택한 노드의 앞쪽 노드가 된다. 
2. 삭제하기 위해 선택한 노드의 다음 노드 포인터 list->crnt->next를 노드 위에서 ptr이 가리키는 노드의 다음 노드 포인터 ptr->next에 대입한다. 그러면 이 노드의 다음 노드 포인터가 가리키는 노드가 노드 삭제하고자 하는 노드의 다음 노드로 업데이터된다. 그런 다음 삭제하고자 하는 노드의 메모리 영역을 해제한다. 



#### 모든 노드를 삭제하는 Clear 함수

Clear 함수는 연결 리스트의 모든 노드를 삭제하는 함수이다. 연결 리스트가 완전히 텅 빈 상태(head == NULL)가 될 때까지 머리 요소의 삭제 작업을 반복한다. 이에 따라 crnt의 값도 NULL로 업데이트 된다.



#### 선택한 노드의 데이터를 출력하는 PrintCurrent 함수

PrintCurrent 함수는 선택한 노드의 데이터를 출력하는 함수이다. 선택한 노드가 없는 경우(list->crnt == NULL)에는 선택한 노드가 없습니다라고 출력한다. 



#### 리스트의 모든 노드를 출력하는 Print 함수

Print 함수는 리스트의 모든 노드를 순서대로 출력하는 함수이다. 머리 노드부터 꼬리 노드까지 포인터 ptr이 가리키는 데이터를 출력한다.



#### 연결 리스트를 종료하는 Terminate 함수

Terminate 함수는 연결 리스트를 종료하는 함수이다. 모든 노드를 삭제하는 Clear 함수를 호출한다. 



![](./Figure/리스트15.JPG)

위의 표는 각 함수를 실행하고 난 후의 crnt 값이다.



#### 자기 참조 구조체와 typedef 선언

![](./Figure/리스트16.JPG)

구조체 Node는 자기 참조형이고 멤버 next는 struct \_\_node형 객체를 가리키는 포인터이다. 자기 참조 구조체란 자기 자신과 같은 자료형의 객체를 가리키는 포인터(struct\_\_node)를 멤버로 가지고 있다는 뜻이다.

![](./Figure/리스트17.JPG)

a처럼 포인터 next가 자기 자신을 가리키는 경우와 다르게 b는 자기 자신과 같은 자료형을 가진 다른 객체를 가리키는 경우도 있다. 이때 Node를 선언하면서(태그 이름인 __node를 부여하면서) typedef 선언도 동시에 하고 있다. 위의 구조체 선언문을 다시 보면 구조체 자료형의 이름인 struct \_\_node에 대해 typedef로 Node라고 이름을 다시 정의하고 있다. 그러면 구조체는 typedef로 정의한 이름도 주어진다. 이때 구조체를 정의하는 부분에서 멤버 next는 struct \_\_node \*형이 아니고 Node\*으로 선언할 수 있다는 실수를 저지를 수 있다. 그러나 이렇게 컴파일 하면 컴파일 오류가 발생한다. 멤버 next를 선언하는 순간에는 아직 Node형의 typedef 선언이 종료되지 않았기 때문이다. 



## 커서로 연결 리스트 만들기	

### 커서로 연결 리스트 만들기

연결 리스트는 노드의 삽입, 삭제를 데이터 이동 없이 수행한다는 특징이 있었지만 삽입, 삭제를 수행할 때마다 노드용 객체를 위한 메모리 영역을 만들고 해제하는 과정이 필요했다. 메모리 영역을 만들고 해제하는데 필요한 비용은 무시할수 없다. 이때 프로그램 실행 중에 데이터의 개수가 크게 바뀌지 않고  데이터 개수의 최댓값을 미리 알 수 있다고 가정하면 배열을 사용해 효율적으로 연결 리스트를 운용할 수 있다.

![](./Figure/리스트18.JPG)

커서를 사용하는 연결 리스트는 데이터 개수의 최대값을 미리 계산하여 모든 노드를 저장하기에 충분한 크기의 배열을 만들어야 한다. 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아니라 다음 노드가 들어 있는 요소의 인덱스에 대한 값이다. 여기서 포인터 역할을 하는 인덱스를 커서(Cursor)라고 한다. 예를 들어 노드 B의 커서 3은 다음 노드 C가 인덱스 3인 위치에 저장되어 있음을 의미한다. 꼬리 노드의 커서는 배열의 인덱스로는 있을 수 없는 값인 -1로 하면 된다. 머리 노드를 나타내는 head도 커서이기 때문에 머리 노드 A가 들어 있는 곳인 인덱스 1인 head의 값이 된다. 이와 같은 방법을 사용하면 노드의 삽입, 삭제 시 요소를 옮길 필요가 없다. 예를 들어서 아래 그림처럼 연결 리스트의 머리에 노드 G를 삽입하면 head를 1에서 6으로 업데이트하고 노드 G의 커서에 1을 대입하게 된다. 

![](./Figure/리스트19.JPG)



#### 커서의 자료형 Index

Index는 커서의 자료형이다. 단순한 정수 값을 가지기 떄문에 int형과 동일하게 정의한다.



#### 노드의 자료형 Node

연결 리스트의 노드를 의미하는 구조체 Node에서 커서 next의 자료형은 커서의 자료형인 Index이다. 



#### 연결 리스트를 관리하는 구조체 List

구조체 List는 연결 리스트를 관리하는 구조체이다.



#### 배열의 비어 있는 요소 처리하기

![](./Figure/리스트20.JPG)

a의 연결 리스트에 있는 데이터가 배열에서 C\->A\->\-D\->B 순서로 저장되는 이유는 다음과 같다.

1.  머리 노드를 가리키는 head의 값은 노드 A가 들어 있는 인덱스 1이다. 
2.  노드 A의 커서 값은 3이다. 다음 노드 B가 인덱스 3인 요소에 들어 있다.
3.  노드 B의 커서 값은 0이다. 다음 노드 C가 인덱스 0인 요소에 들어 있다.
4.  노드 C의 커서 값은 2이다. 다음 노드 D가 인덱스 2인 요소에 들어 있다.
5.  노드 D으 커서 값은 꼬리 노드이기 때문에 -1이다.

b의 연결 리스트의 머리에 노드 E를 삽입한 상태이다. 인덱스가 4인 위치에 노드 E가 들어 있다. 

1.  머리 노드를 가리키는 head의 값은 노드 E가 들어 있는 인덱스의 값인 4로 바뀐다. 
2.  삽입한 노드 E는 다음 노드 A가 인덱스 1에 들어 있으므로 커서의 값을 1로 지정한다. 

이렇게 삽입한 노드는 물리적으로는 배열의 꼬리 인덱스 위치에 들어 있는 것 같지만 연결 리스트의 꼬리에 추가한 것이 아니라 머리에 삽입한 것이다. 다시 말해 배열에 저장한 데이터의 물리적인 위치는 연결 리스트에 저장된 데이터의 논리적인 순서와 다르다. 여기서는 배열의 n번째 인덱스에 들어 있는 노드를 n번째 레코드라고 하기로 한다. 삽입한 노드 E는 4번째 레코드에 있다.

c에서는 3번째 노드 B를 삭제한 상태이다. 노드를 삭제하면 3번째 레코드가 비어 있는 상태가 된다.  이때 노드 B를 삭제하면 노드 A의 다음 노드는 C로 바뀐다. 따라서 노드 A의 커서 값도 3에서 0으로 업데이트 한다. 

이렇게 삭제를 여러 번 하면 배열은 빈 레코드가 너무 많아져 효율이 떨어진다. 그렇기 때문에 비어 있는 레코드를 효율적으로 활용해야 한다. 



## 프리 리스트

삭제한 여러 레코드를 관리하면 사용하지 않는 빈 배열의 문제를 해결할 수 있다. 이때 삭제한 레코드를 관리하기 위해 사용하는 자료구조는 프리 리스트(Free list)이다. 프리 리스트는 앞에서 다룬 커서로 연결 리스트 만들기와 삭제한 레코드를 관리하기 위한 프리 리스트를 결합해 구현할 수 있다. 따라서 노드용 구조체 Node와 연결 리스트를 관리하는 구조체 List에 포인터 버전에 없는 멤버를 추가한다. 

- 노드 구조체 Node에 추가한 멤버 : Dnext \- 프리 리스트의 다음 노드를 가리키는 커서
- 연결 리스트를 관리하는 구조체 List에 추가한 멤버 
  - deleted :  프리 리스트의 머리 노드를 가리키는 커서
  - max : 배열의 가장 꼬리 쪽에 들어 있는 노드의 레코드 번호(배열 인덱스)를 의미한다.

![](./Figure/리스트21.JPG)

a : 연결 리스트에 5개의 노드 A\->B\->C\->D\->E가 순서대로 저장되어 있다. max 값은 7이며, 8번째 레코드는 아직 사용되지 않은 상태이다. 또한 3개의 레코드 1, 3, 5가 삭제를 마치면 프리 리스트는 3\->1\->5가 된다. 데이터를 저장했던 연결 리스트(배열)에 프리 리스트를 위한 공간을 추가하여 삭제한 레코드까지 관리하는 연결 리스트를 구현한다. 연결 리스트 구조체 List의 멤버 deleted의 값은 프리 리스트의 머리 노드의 인덱스 값이다. 

b : 연결 리스트 꼬리에 노드 F를 삽입한 이후의 상태이다. 노드를 삽입하는 위치는 새로 정하는 것이 아니라 프리 리스트의 머리 노드의 값을 사용한다. 따라서 노드 F를 3번째 레코드에 저장하고 프리 스트에서 3을 삭제한다. 이런 방법으로 프리 리스트에 빈 레코드가 등록된 경우에는 새 레코드를 지정하고 max의 값을 증가한 다음 해당 레코드에 데이터를 저장하지 않는다. 따라서 max의 값은 8이 아니라 7인 상태를 유지한다. 

c : 노드 D를 삭제한 다음의 상태이다. 7번째 레코드에 넣어둔 데이터를 삭제했기 때문에 7을 프리 리스트의 머리 노드로 추가한다. 

삭제한 레코드를 프리 리스트에 등록하는 함수의 이름은 DeleteIndex이고 노드를 삽입할 때 레코드 번호를 정하는 함수의 이름은 GetIndex이다. 만약 삭제한 레코드가 없어 프리 리스트가 비어 있다면 max의 값을 1만큼 증가하고 배열 꼬리의 아직 사용하지 않은 레코드를 사용한다. 



## 원형 이중 연결 리스트

### 원형 리스트 

![](./Figure/리스트22.JPG)

위 그림과 같이 선형 리스트의 꼬리 노드가 머리 노드를 가리키면 원형 리스트(Circular list)라고 한다. 원형 리스트는 고리 모양으로 나열된 데이터를 저장할 때 알맞은 자료구조이다.  원형 리스트와 선형 리스트의 차이점은 꼬리 노드의 다음 노드를 가리키는 포인터가 널(NULL)이 아니라 머리 노드의 포인터 값이라는 점이다. 원형 리스트는 선형 리스트에서 사용했던 것과 같은 자료형을 사용할 수 있다. 여기서는 리스트를 관리하는 구조체 포인터를 list라고 하기로 한다. 



#### 빈 원형 리스트를 판단하는 방법

노드가 없는(비어 있는) 원형 리스트인지 판단하려면 다음 식을 사용한다.

- list->head == NULL 



#### 노드가 1개인 원형 리스트를 판단하는 방법

노드가 1개라면 머리 노드의 다음 포인터는 자기 자신인 머리 노드를 가리킨다. 노드가 1개인 원형 리스트를 판단하려면 다음 식을 사용한다.

- list->head->next == list->head



#### 머리 노드인지 판단하는 방법

Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 머리 노드인지 판단하려면 다음 식을 사용한다.

- p == list->head



#### 꼬리 노드인지 판단하는 방법

Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 꼬리 노드인지 판단하려면 다음 식을 사용한다.

p->next == list->head



### 이중 연결 리스트

선형 리스트의 가장 큰 단점은 다음 노드는 찾기 쉽지만 앞쪽의 노드는 찾을 수 없다는 점이다. 이 단점을 개선한 자료구조가 이중 연결 리스트(Doubly linked list)이다. 각 노드에는 다음 노드에 대한 포인터와 앞쪽의 노드에 대한 포인터가 주어진다. 

![](./Figure/리스트23.JPG)

이중 연결 리스트의 노드는 다음과 같이 3개의 멤버가 있는 구조체를 사용한다.

![](./Figure/리스트24.JPG)



#### 머리 노드인지 판단하는 방법

Dnoe *형 변수 p가 리스트의 어떤 노드를 가리키는 경우 p가 가리키는 노드가 이중 연결 리스트의 머리 노드인지 판단하려면 다음 식을 사용한다(다음 두 가지 방법 중 하나 선택).

- p == list->head
- p->prev == NULL



#### 꼬리 노드인지 판단하는 방법

또 p가 가리키고 있는 노드가 꼬리 노드인지 판단하려면 다음 식을 사용한다.

- p->next == NULL



## 원형 이중 연결 리스트

![](./Figure/리스트25.JPG)



#### 노드를 나타내는 구조체 Dnode

노드의 자료형 Dnode는 이중 연결 리스트의 노드에서 사용했었다. 

![](./Figure/리스트26.JPG)



#### 원형 이중 연결 리스트를 관리하는 구조체 Dlist

원형 이중 연결 리스트를 관리하는 구조체는 선형 리스트의 List와 마찬가지로 머리 노드에 대한 포인터와 선택한 노드에 대한 포인터를 가지고 있다. 



#### 노드를 생성하는 AllocDnode 함수

AllocDnode 함수는 Dnode형 객체를 생성하고 해당 객체의 포인터를 반환하는 함수이다.



#### 노드의 멤버 값을 설정하는 SetDnode 함수

SetDnode 함수는 Dnode형 객체의 멤버 값을 설정한다. 이때 첫 번째 매개변수 n에 전달받은 Dnode형 객체 포인터를 통해 멤버 값을 설정한다. 객체 멤버인 data, prev, next에 두 번째 매개변수가 가리키는 객체의 값, 세 번째 매개변수와 네 번쨰 매개변수의 포인터 값을 대입한다.



#### 원형 이중 연결 리스트를 초기화하는 Initialize 함수

Initialize 함수는 텅 비어 있는 상태의 원형 이중 연결 리스트를 만드는 함수로 비어 있는 상태의 노드 1개를 만들어 리스트를 초기화 한다. 초기화를 통해 만들어낸 노드는 노드의 삽입, 삭제를 수행하기 위해 리스트의 머리에 위치하고 더미 노드라고 부른다. 더미 노드를 만든 다음에는 더미 노드의 앞쪽 포인터 prev와 뒤쪽 포인터 next 모두 자기 자신(더미 노드)을 가리키도록 설정하면 초기화가 끝난다. 

![](./Figure/리스트27.JPG)



#### 리스트가 비어 있는지 검사하는 IsEmpty 함수

IsEmpty 함수는 리스트가 비어 있는지를 검사하는 함수이다. 더미 노드의 뒤쪽 포인터 list->head->next가 더미 노드인 list->head를 가리키면 비어 있는 상태라고 판단한다. 비어 있는 상태의 리스트는 list->head, 더미 노드의 앞쪽 포인터인 list->head->prev, 더미 노드의 뒤쪽 포인터인 list->head->next의 4개 모두 더미 노드를 가리킨다. 함수의 반환 값은 리스트가 비어 있는 경우에는 1이다(아닌 경우에는 0).



#### 선택한 노드의 데이터를 출력하는 PrintCurrent 함수

PrintCurrent 함수는 선택한 노드의 데이터를 출력하는 함수이다. 다시 말해 list->crnt가 가리키는 노드의 데이터를 PrintMember 함수를 이용해 출력한다. 리스트가 비어 있는 경우에는 선택한 노드가 없다라는 메세지를 출력한다. 



#### 노드를 검색하는 Search 함수

Search 함수는 리스트에서 노드를 선형 검색하는 함수이다. 머리 노드부터 뒤쪽 포인터를 이용해 순서대로 스캔한다. 이때 머리 노드는 더미 노드가 아니라 더미 노드의 다음 노드이다. 즉 다음 그림에서 list->head가 가리키는 더미 노드의 뒤쪽 포인터가 가리키는 노드 A가 머리 노드이다. 따라서 검색을 시작하는 노드의 위치는 list->head가 아니라 list->head->next이다. 꼬리 노드는 head->prev이다. 

![](./Figure/리스트28.JPG)

Node *형의 포인터 a, b, c, d, e가 각각 노드 A, B ..., E를 순서대로 가리키는 경우 각 노드를 가리키는 식은 다음과 같다. 

![](./Figure/리스트29.JPG)

Search 함수는 while문으로 노드를 하나씩 스캔하는 과정에서 비교 함수인 compare 함수를 사용한다. compare 함수로 비교한 결과가 0이면 검색 성공이며 찾은 노드에 대한 포인터인 ptr을 반환한다. 이때 crnt는 찾은 노드(ptr)를 가리키도록 설정한다. 노드를 찾지 못하고 한 바퀴 돌아서 다시 더미 노드로 돌아오면(ptr과 head가 같다면) 검색에 실패한 것이다. 이때는 while문을 종료하고 널(NULL)을 반환한다. 

빈 리스트를 검색하느 경우에는 더미 노드만 있게 되는데 ptr에 대입하는 list->head->next 값은 더미 노드에 대한 포인터이다. 다시 말해 list->head와 같은 값이 ptr에 대입된다. 그러면 while문의 제어식 ptr != list->head가 성립되지 않기 때문에 while문은 실행되지 않고 바로 NULL을 반환하면 함수가 종료 된다. 

![](./Figure/리스트30.JPG)



#### 원형 이중 연결 리스트에서 p가 가리키는 노드의 위치를 판단하는 방법

원형 이중 연결 리스트에서 Dnode *형의 포인터 p가 리스트의 어떤 노드를 가리키는 경우 p가 가리키는 노드의 위치를 판단하려면 다음 식을 사용한다.

- p->prev == list->head : p가 가리키는 노드가 머리 노드인지 확인
- p->prev->prev == list->head : p가 가리키는 노드가 2번째 노드인지 확인
- p->next == list->head : p가 가리키는 노드가 꼬리 노드인지 확인
- p->next->next == list->head : p가 가리키는 노드가 2번째 노드인지 확인



#### 모든 노드를 순서대로 출력하는 Print 함수

Print 함수는 리스트의 모든 노드를 머리부터 순서대로 출력하는 함수이다. list->head->next부터 스캔하기 시작해 뒤쪽 포인터를 찾아가며 각 노드의 데이터를 출력하면 된다. 다시 head로 돌아오면 스캔을 종료한다. 

![](./Figure/리스트31.JPG)



#### 모든 노드를 거꾸로 출력하는 PrintReverse 함수

PrintReverse 함수는 리스트의 모든 노드를 꼬리부터 거꾸로 출력하는 함수이다.

![](./Figure/리스트32.JPG)



#### 선택한 노드의 다음으로 진행시키는 Next 함수

Next 함수는 선택한 노드의 다음 노드로 진행시키는 함수이다. 리스트가 비어 있지 않고 선택한 도으의 다음 노드가 있는 경우메만 동작한다. 선택한 노드가 다음 노드로 진행하는데 성공하면 1, 실패하면 0을 반환한다.



#### 선택한 노드의 앞쪽으로 진행시키는 Prev 함수

Prev 함수는 선택한 노드의 바로 앞쪽 노드로 되돌아가게 하는 함수이다. 



#### 바로 다음에 노드를 삽입하는 InsertAfter 함수

InsertAfter 함수는 포인터 p가 가리키는 노드의 바로 다음에 노드를 삽입한다. 

![](./Figure/리스트33.JPG)

a는 p가 노드 B를 가리키고 있는 상태이다. 이때 노드 B 다음에 노드 D를 삽입하면 b와 같은 상태가 된다. 노드를 삽입한 위치는 p가 가리키는 노드와 p->next가 가리키는 노드의 사이이다. 삽입하는 과정은 다음과 같다.

1. 새로 삽입할 노드를 만들고 만든 노드의 앞쪽 포인터가 가리키는 노드는 B, 뒤쪽 포인터가 가리키는 노드는 C로 설정한다.
2. 노드 B의 뒤쪽 포인터 p->next와 노드 C의 앞쪽 포인터 p->next->prev 모두 새로 삽입한 노드인 ptr(노드 D)을 가리키도록 업데이트한다.
3. 선택한 노드 list->crnt가 삽입한 도를 가리키도록 업데이트 한다. 

이때 리스트 머리에 더미 노드가 있어 비어 있는 리스트에 삽입하는 경우와 리스트 머리에 삽입하는 경우를 따로 처리하지 않아도 된다.  노드 A를 빈 리스트에 삽입할 때, 삽입하기 전에 crnt, head는 모두 더미 노드를 가리키고 있기 떄문에 삽입하는 과정은 다음과 같다.

![](./Figure/리스트34.JPG)

1. 만든 노드의 앞쪽 포인터와 뒤쪽 포인터는 더미 노드를 가리킨다.
2. 더미 노드의 뒤쪽 포인터와 앞쪽 포인터가 가리키는 노드는 A이다.
3. 선택한 노드가 가리키는 노드는 A이다.



#### 머리에 노드를 삽입하는 InsertFront 함수

InsertFront함수는 리스트의 머리에 노드를 삽입하는 함수로, 더미 노드의 바로 뒤에 삽입한다. 즉, InsertAfter 함수를 사용해 list->head가 가리키는 더미 노드 뒤에 노드를 삽입한다.



#### 꼬리에 노드를 삽입하는 InsertRear 함수

InsertRear 함수는 리스트의 꼬리에 노드를 삽입하는 함수이다. 



#### 노드를 삭제하는 Remove 함수 

Remove 함수는 p가 가리키는 노드를 삭제하는 함수이다. 

![](./Figure/리스트35.JPG)

a는 삭제하기 전의 상태이다. 노드 A(p->prev)와 노드 C(p->next) 사이에 있는 노드 B를 삭제한 다음의 상태는 b가 되면 삭제하는 과정은 다음과 같다.

1. 노드 A의 뒤쪽 포인터 p->prev->next가 가리키는 노드가 C(p->next)가 되도록 업데이트 한다.
2. 노드 C의 앞쪽 포인터 p->next->prev가 가리키는 노드가 A(p->prev)가 되도록 업데이트 한다. 그런 다음 p가 가리키는 메모리 영역을 해제한다.
3. 선택한 노드가 삭제한 노드의 앞쪽 노드 A를 가리킬 수 있도록 crnt를 업데이트 한다.



#### 머리 노드를 삭제하는 RemoveFront 함수

RemoveFront 함수는 머리 노드를 삭제하는 함수로,  Remove 함수를 사용해 포인터 list->head->next가 가리키는 머리 노드를 삭제한다. 이때 더미 노드는 삭제하면 안된다. 따라서 list->head가 가리키는 더미 노드가 아닌 그 다음의 노드 list->head->next를 삭제한다.



#### 꼬리 노드를 삭제하는 RemoveRear 함수

RemoveRear 함수는 꼬리 노드를 삭제하는 함수로, 포인터 list->head->prev가 가리키는 꼬리 노드르 삭제한다.



#### 선택한 노드를 삭제하는 RemoveCurrent 함수

RemoveCurrent 함수는 선택한 노드를 삭제하는 함수로, 포인터 list->crnt가 가리키는 노드를 삭제한다. 



#### 모든 노드를 삭제하는 Clear 함수

Clear 함수는 더미 노드를 제외하고 모든 노드를 삭제하는 함수로, 리스트가 텅 빌 때까지 RemoveFront 함수를 사용해 머리 노드의 삭제를 반복한다. 삭제가 끝나면 선택한 노드에 대한 포인터 list->crnt가 가리키는 노드는 더미 노드 list->head로 업데이트 한다.



#### 원형 이중 연결 리스트를 종료하는 Terminate 함수

Terminate 함수는 원형 이중 연결 리스트를 종료하는 함수이다. 먼저 Clear 함수를 호출해 모든 노드를 삭제하고 더미 노드의 메모리 영역도 해제한다.